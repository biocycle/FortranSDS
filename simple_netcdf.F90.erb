<% TYPE = {
     '_str' => 'character(*)',
     'i' => 'integer',
     'f' => 'real*4',
     'd' => 'real*8'
} %>
<%= "!!! DO NOT EDIT THIS FILE DIRECTLY!!!" %>
<%= "!!! AUTO-GENERATED FROM simple_netcdf.F90.erb !!!" %>

! NetCDF wrapper functions to make it easier to read and write NetCDF files,
! especially CF-compliant files.  Also gives more useful error messages.
module SimpleNetCDF
    use netcdf
    implicit none

    type SNCFile
        integer :: ncid
        character(512) :: name
        integer :: ndims, cfdimids(5)
        character(32) :: z_name ! name of the vertical dimension
    end type SNCFile

    type SNCVar
        integer :: id
        character(128) :: name
        integer :: ndims, dims(6) ! number of dimensions and dimension sizes
    end type SNCVar

    interface snc_get_dim
        module procedure snc_get_dim_by_id, snc_get_dim_by_name
    end interface snc_get_dim

    interface snc_cf_write_coords
        module procedure snc_cf_write_coords2f, snc_cf_write_coords2d
        module procedure snc_cf_write_coords3f, snc_cf_write_coords3d
    end interface snc_cf_write_coords

    ! read 1-4 dimensional arrays of type integer, float (real*4)
    ! or double (real*8).
    interface snc_read
        module procedure snc_read1i, snc_read1f, snc_read1d
        module procedure snc_read2i, snc_read2f, snc_read2d
        module procedure snc_read3i, snc_read3f, snc_read3d
        module procedure snc_read4i, snc_read4f, snc_read4d
    end interface snc_read

    ! write 1-4 dimensional arrays of type integer, float or double.
    interface snc_write
        module procedure snc_write1i, snc_write1f, snc_write1d
        module procedure snc_write2i, snc_write2f, snc_write2d
        module procedure snc_write3i, snc_write3f, snc_write3d
        module procedure snc_write4i, snc_write4f, snc_write4d
    end interface snc_write

    interface snc_get_att
        module procedure snc_get_att_str, snc_get_atti, snc_get_attf, snc_get_attd
    end interface snc_get_att

    interface snc_put_att
        module procedure snc_put_att_str, snc_put_atti, snc_put_attf, snc_put_attd
    end interface snc_put_att

    interface snc_get_global_att
        module procedure snc_get_gatt_str, snc_get_gatti, snc_get_gattf, snc_get_gattd
    end interface snc_get_global_att

    interface snc_put_global_att
        module procedure snc_put_gatt_str, snc_put_gatti, snc_put_gattf, snc_put_gattd
    end interface snc_put_global_att

    integer, parameter :: SNC_UNLIMITED = NF90_UNLIMITED

    integer, parameter :: SNC_INT       = NF90_INT
    integer, parameter :: SNC_FLOAT     = NF90_FLOAT
    integer, parameter :: SNC_DOUBLE    = NF90_DOUBLE

    integer, parameter :: READ_MODE = NF90_SHARE
#ifndef HAVE_NETCDF4
    integer, parameter :: WRITE_MODE = NF90_NOCLOBBER
    integer, parameter :: OVERWRITE_MODE = NF90_CLOBBER
#else
    integer, parameter :: WRITE_MODE = IOR(NF90_NOCLOBBER, NF90_HDF5)
    integer, parameter :: OVERWRITE_MODE = IOR(NF90_CLOBBER, NF90_HDF5)
    integer, parameter :: SNC_DEFAULT_DEFLATE = 6
#endif

    ! Common calendars
    character(16), parameter :: SNC_STANDARD_CAL = "standard" ! udunits' mixed gregorian/julian calendar
    character(16), parameter :: SNC_NOLEAP = "noleap" ! all years are 365 days long

contains

    ! CF COMPLIANCY SECTION ---


    ! Create a new CF-compliant gridded data file.
    !
    ! filename: the path name of the NetCDF file to create.
    ! lon_size: the number of longitude grid points.
    ! lat_size: the number of grid points along the latitude (Y)
    ! time_units: A UDUNITS-compatible time format like:
    !       seconds since 2012-02-01 03:05:22.0 -7:00
    !   so we have a time unit (seconds) since an absolute time, namely 3
    !   hours, 5 minutes and 22 seconds into February 1 2012, with timezone
    !   offset of -7 hours (Mountain Standard Time).  Often you will want
    !   to start at the beginning of a particular day and use UTC time
    !   (no timezone offset), so you can use a simpler format like:
    !       hours since 2012-01-01
    !   Note that the time unit can be anything allowed by the UDUNITS
    !   package, but most commonly this will be seconds, hours or days.
    !   Time units of months or years can cause problems because both years
    !   and months are of varying lengths, so their use is discouraged.
    ! calendar: specifies the type of calendar so that dates can be properly
    !   calculated.  Normally you will want to use SNC_STANDARD_CAL if you
    !   are dealing with the standard western (gregorian) calendar for,
    !   e.g. satellite data.  If you are dealing with a gregorian calendar
    !   without leap years (every year is 365 days long), use SNC_NOLEAP.
    !   See the [CF Docs](http://cf-pcmdi.llnl.gov/) for other calendars.
    ! title: optional. "A succinct description of what is in the dataset."
    !   e.g. "CO2 fluxes".
    ! source: optional. "The method of production of the original data. If it
    !   was model-generated, source should name the model and its version, as
    !   specifically as could be useful.  If it is observational, source
    !   should characterize it..." e.g. "radiosonde" or "SiB 3".
    !
    ! Other attributes you might consider adding with snc_put_att():
    ! - comment: "Miscellaneous information about the data or methods used
    !     to produce it."
    ! - history: A list of programs that modified this file, what and when
    !     they did it.
    ! - institution: The name of the facility where the data was created.
    function snc_cf_grid_create(filename, lon_size, lat_size, time_units, &
        calendar, title, source, overwrite, src_file, src_line)
        character(*), intent(in) :: filename
        integer, intent(in) :: lat_size, lon_size
        character(*), intent(in) :: time_units
        character(*), intent(in) :: calendar
        character(*), intent(in), optional :: title, source
        logical, intent(in), optional :: overwrite
        character(*), intent(in), optional :: src_file
        integer, intent(in), optional :: src_line
        type(SNCFile) :: snc_cf_grid_create, file
        type(SNCVar) :: var, global_var
        integer :: lat_id, lon_id, time_id

        file = snc_create(filename, overwrite, src_file, src_line)

        ! dimensions
        lat_id = snc_def_dim(file, "lat", lat_size, src_file, src_line)
        lon_id = snc_def_dim(file, "lon", lon_size, src_file, src_line)
        time_id = snc_def_dim(file, "time", SNC_UNLIMITED, src_file, src_line)

        ! coordinate variables
        var = snc_cf_def_var(file, "lon", "longitude", SNC_FLOAT, "degrees_east", &
            (/lon_id/), standard_name = "longitude", &
            src_file = src_file, src_line = src_line)
        call snc_put_att(file, var, "axis", "X", src_file, src_line)

        var = snc_cf_def_var(file, "lat", "latitude", SNC_FLOAT, "degrees_north", &
            (/lat_id/), standard_name = "latitude", &
            src_file = src_file, src_line = src_line)
        call snc_put_att(file, var, "axis", "Y", src_file, src_line)

        var = snc_cf_def_var(file, "time", "time", SNC_FLOAT, time_units, (/time_id/), &
            src_file = src_file, src_line = src_line)
        call snc_put_att(file, var, "axis", "T", src_file, src_line)
        call snc_put_att(file, var, "calendar", calendar, src_file, src_line)

        ! global attributes
        global_var%id = NF90_GLOBAL
        global_var%name = "-global-"

        call snc_put_att(file, global_var, "Conventions", "CF-1.6", src_file, src_line)
        if (present(title)) then
            call snc_put_att(file, global_var, "title", title, src_file, src_line)
        end if
        if (present(source)) then
            call snc_put_att(file, global_var, "source", source, src_file, src_line)
        end if

        ! leave in define mode so user can do whatever else they need to
        file%ndims = 3
        file%cfdimids(1) = lon_id
        file%cfdimids(2) = lat_id
        file%cfdimids(3) = time_id
        snc_cf_grid_create = file
    end function snc_cf_grid_create

    ! Define a CF-compliant vertical coordinate for a NetCDF file.
    !
    ! file: the SNCFile returned by snc_cf_grid_create().
    ! z_size: the size of the vertical dimension.
    ! name: the name of the vertical dimension and coordinate variable.
    ! long_name: the long name for the vertical coordinate variable.
    ! units: the units for the vertical coordinate variable.
    ! positive: the direction of positive values, either "up" or "down".
    ! standard_name: optional. a name from
    !   http://cf-pcmdi.llnl.gov/documents/cf-standard-names/
    !   matching this variable.
    subroutine snc_cf_grid_vertical(file, z_size, name, long_name, units, &
        positive, standard_name, src_file, src_line)

        type(SNCFile), intent(inout) :: file
        integer, intent(in) :: z_size
        character(*), intent(in) :: name, long_name, units, positive
        character(*), intent(in), optional :: standard_name
        character(*), intent(in), optional :: src_file
        integer, intent(in), optional :: src_line
        integer :: z_id
        type(SNCVar) :: var

        z_id = snc_def_dim(file, name, z_size, src_file, src_line)

        var = snc_cf_def_var(file, name, long_name, SNC_FLOAT, units, &
            (/z_id/), standard_name, src_file = src_file, src_line = src_line)
        call snc_put_att(file, var, "axis", "Z", src_file, src_line)
        call snc_put_att(file, var, "positive", positive, src_file, src_line)

        if (file%ndims == 3) then
            file%ndims = 4
            file%cfdimids(4) = file%cfdimids(3) ! move time id to end
            file%cfdimids(3) = z_id
        else
            if (present(src_file) .and. present(src_line)) then
                write(*, "(A,' line',I5,': ',A)") src_file, src_line, &
                    "in snc_cf_grid_vertical() - file%ndims /= 3"
            else
                write(*, "(A)") "in snc_cf_grid_vertical() - file%ndims /= 3"

            end if
            stop
        end if

        file%z_name = name
    end subroutine snc_cf_grid_vertical

    ! Define a CF-compliant NetCDF variable.
    !
    ! file: the SNCFile returned from snc_cf_grid_create().
    ! varname: the name of the variable.
    ! long_name: a more descriptive name for the variable.
    ! type: a type for the variable; usually one of SNC_INT, SNC_FLOAT or
    !   SNC_DOUBLE.
    ! units: the units for the variable, compatible with UDUNITS.
    ! dimids: optional.  An array of dimension IDs.  The default is to use
    !   the full (time, lat, lon) or (time,<vert>,lat,lon) dimensions
    !   defined with snc_cf_grid_create() and snc_cf_grid_vertical().
    ! standard_name:  optional. a name from
    !   http://cf-pcmdi.llnl.gov/documents/cf-standard-names/
    !   matching this variable.
    ! missing_value: optional. A value used for missing data in the variable.
    !   NOT FOR COORDINATE VARIABLES.
    ! fill_value: optional. A value for missing or undefined data.
    !   NOT FOR COORDINATE VARIABLES.
    ! valid_min: optional. Smallest valid value in the variable.
    ! valid_max: optional. Largest valid value in the variable.
    function snc_cf_def_var(file, varname, long_name, type, units, dimids, &
        standard_name, missing_value, fill_value, valid_min, valid_max, &
        src_file, src_line)

        type(SNCFile), intent(in) :: file
        character(*), intent(in) :: varname, long_name, units
        integer, intent(in) :: type
        integer, intent(in), optional :: dimids(:)
        character(*), intent(in), optional :: standard_name
        real, intent(in), optional :: missing_value
        character(*), intent(in), optional :: fill_value, valid_min, valid_max
        character(*), intent(in), optional :: src_file
        integer, intent(in), optional :: src_line
        type(SNCVar) :: var, snc_cf_def_var

        if (present(dimids)) then
            var = snc_def_var(file, varname, type, dimids, src_file, src_line)
        else
            var = snc_def_var(file, varname, type, file%cfdimids(1:file%ndims), &
                src_file, src_line)
        end if

        call snc_put_att(file, var, "long_name", long_name, src_file, src_line)
        call snc_put_att(file, var, "units", units, src_file, src_line)

        if (present(standard_name)) then
            call snc_put_att(file, var, "standard_name", standard_name, src_file, src_line)
        end if
        if (present(missing_value)) then
            if (type == SNC_FLOAT .or. type == SNC_DOUBLE) then
                call snc_put_att(file, var, "missing_value", missing_value, &
                    src_file, src_line)
            else
                call snc_put_att(file, var, "missing_value", int(missing_value), &
                    src_file, src_line)
            end if
        end if
        if (present(fill_value)) then
            call snc_put_att(file, var, "_FillValue", fill_value, src_file, src_line)
        end if
        if (present(valid_min)) then
            call snc_put_att(file, var, "valid_min", valid_min, src_file, src_line)
        end if
        if (present(valid_max)) then
            call snc_put_att(file, var, "valid_max", valid_max, src_file, src_line)
        end if

        snc_cf_def_var = var
    end function snc_cf_def_var

    ! Write the coordinate variables to a CF-compliant NetCDF file.
%   'fd'.each_char do |t|
    subroutine snc_cf_write_coords2<%= t %>(file, lon, lat, time, src_file, src_line)
        type(SNCFile), intent(in) :: file
        <%= TYPE[t] %>, intent(in), dimension(:) :: lon, lat, time
        character(*), intent(in), optional :: src_file
        integer, intent(in), optional :: src_line
        type(SNCVar) :: var

        var = snc_inq_var(file, "lat", src_file = src_file, src_line = src_line)
        call snc_write(file, var, lat, src_file = src_file, src_line = src_line)

        var = snc_inq_var(file, "lon", src_file = src_file, src_line = src_line)
        call snc_write(file, var, lon, src_file = src_file, src_line = src_line)

        var = snc_inq_var(file, "time", src_file = src_file, src_line = src_line)
        call snc_write(file, var, time, src_file = src_file, src_line = src_line)
    end subroutine snc_cf_write_coords2<%= t %>


    subroutine snc_cf_write_coords3<%= t %>(file, lon, lat, z, time, src_file, src_line)
        type(SNCFile), intent(in) :: file
        <%= TYPE[t] %>, intent(in), dimension(:) :: lon, lat, z, time
        character(*), intent(in), optional :: src_file
        integer, intent(in), optional :: src_line
        type(SNCVar) :: z_var

        call snc_cf_write_coords(file, lon, lat, time, src_file, src_line)

        z_var = snc_inq_var(file, file%z_name, src_file = src_file, src_line = src_line)
        call snc_write(file, z_var, z, src_file = src_file, src_line = src_line)
    end subroutine snc_cf_write_coords3<%= t %>


% end


    ! OPEN SECTION ---


    ! Open a NetCDF file for reading
    function snc_open(filename, src_file, src_line)
        character(*), intent(in) :: filename
        character(*), intent(in), optional :: src_file
        integer, intent(in), optional :: src_line
        type(SNCFile) :: snc_open
        character(530) :: err_msg

        write(err_msg, "('opening ',A)") trim(filename)
        call snc_handle_error(nf90_open(filename, READ_MODE, snc_open%ncid), &
            err_msg, src_file, src_line)
        snc_open%name = filename
    end function snc_open

    ! Open a NetCDF file for writing
    function snc_create(filename, overwrite, src_file, src_line)
        character(*), intent(in) :: filename
        logical, intent(in), optional :: overwrite
        character(*), intent(in), optional :: src_file
        integer, intent(in), optional :: src_line
        type(SNCFile) :: snc_create
        character(530) :: err_msg
        integer :: mode

        if (present(overwrite) .and. overwrite) then
            mode = OVERWRITE_MODE
        else
            mode = WRITE_MODE
        end if

        write(err_msg, "('creating ',A)") trim(filename)
        call snc_handle_error(nf90_create(filename, mode, snc_create%ncid), &
            err_msg, src_file, src_line)
        snc_create%name = filename
    end function snc_create


    ! DIMENSIONS SECTION ---


    ! Returns the NetCDF ID for the given dimension name.
    function snc_get_dimid(file, dimname, src_file, src_line)
        type(SNCFile), intent(in) :: file
        character(*), intent(in) :: dimname
        character(*), intent(in), optional :: src_file
        integer, intent(in), optional :: src_line
        integer :: snc_get_dimid
        character(700) :: err_msg

        write(err_msg, "('getting id for dimension ''',A,''' in ',A)") &
            trim(dimname), trim(file%name)
        call snc_handle_error(nf90_inq_dimid(file%ncid, dimname, snc_get_dimid), &
            err_msg, src_file, src_line)
    end function snc_get_dimid

    ! Returns the size of the ID'd dimension
    function snc_get_dim_by_id(file, dimid, src_file, src_line)
        type(SNCFile), intent(in) :: file
        integer, intent(in) :: dimid
        character(*), intent(in), optional :: src_file
        integer, intent(in), optional :: src_line
        integer :: snc_get_dim_by_id
        character(128) :: dimname
        character(700) :: err_msg

        write(err_msg, "('getting name for dimid ',I5,'in ',A)") &
            dimid, trim(file%name)
        call snc_handle_error(nf90_inquire_dimension(file%ncid, dimid, dimname), &
            err_msg, src_file, src_line)

        write(err_msg, "('getting length for dimension ''',A,''' in ',A)") &
            trim(dimname), trim(file%name)
        call snc_handle_error(nf90_inquire_dimension(file%ncid, dimid, len = snc_get_dim_by_id), &
            err_msg, src_file, src_line)
    end function snc_get_dim_by_id

    ! Returns the size of the named dimension
    function snc_get_dim_by_name(file, dimname, src_file, src_line)
        type(SNCFile), intent(in) :: file
        character(*), intent(in) :: dimname
        character(*), intent(in), optional :: src_file
        integer, intent(in), optional :: src_line
        integer :: snc_get_dim_by_name
        integer :: dimid
        character(700) :: err_msg

        dimid = snc_get_dimid(file, dimname, src_file, src_line)

        write(err_msg, "('getting length for dimension ''',A,''' in ',A)") &
            trim(dimname), trim(file%name)
        call snc_handle_error(nf90_inquire_dimension(file%ncid, dimid, len = snc_get_dim_by_name), &
            err_msg, src_file, src_line)
    end function snc_get_dim_by_name

    ! Defines a dimension with the given name and size, then returns its id
    ! for use in defining variables later.
    function snc_def_dim(file, dimname, dimsize, src_file, src_line)
        type(SNCFile), intent(in) :: file
        character(*), intent(in) :: dimname
        integer, intent(in) :: dimsize
        character(*), intent(in), optional :: src_file
        integer, intent(in), optional :: src_line
        integer :: snc_def_dim
        integer :: dimid
        character(700) :: err_msg

        write(err_msg, "('defining dimension ''',A,''' = ',I6,'in ',A)") &
            trim(dimname), dimsize, trim(file%name)
        call snc_handle_error(nf90_def_dim(file%ncid, dimname, dimsize, dimid), &
            err_msg, src_file, src_line)
        snc_def_dim = dimid
    end function snc_def_dim



    ! VARIABLES SECTION ---


    ! Looks for the given variable name in the NetCDF file and gets its
    ! dimensions.
    ! units: optional.  Reads the 'units' attribute into this
    ! argument.  expect: optional.  An array of integers giving the
    !   expected size of each variable dimension.  If these do not match
    !   the actual size of the variable, an error message will be
    !   printed and the program stopped.
    function snc_inq_var(file, varname, units, src_file, src_line)
        type(SNCFile), intent(in) :: file
        character(*), intent(in) :: varname
        character(*), intent(out), optional :: units
        character(*), intent(in), optional :: src_file
        integer, intent(in), optional :: src_line
        type(SNCVar) :: snc_inq_var
        character(700) :: err_msg
        integer :: status, i, dimids(4)

        snc_inq_var%name = varname

        write(err_msg, "('inquiring variable''s id ''',A,''' in ',A)") &
            trim(varname), trim(file%name)
        status = nf90_inq_varid(file%ncid, varname, snc_inq_var%id)
        call snc_handle_error(status, err_msg, src_file, src_line)

        write(err_msg, "('inquiring about variable ''',A,''' in ',A)") &
            trim(varname), trim(file%name)
        status = nf90_inquire_variable(file%ncid, snc_inq_var%id, &
            ndims = snc_inq_var%ndims, dimids = dimids)
        call snc_handle_error(status, err_msg, src_file, src_line)
        if (snc_inq_var%ndims > size(dimids)) then
            print "('Too many dimensions in variable ''',A,''' in ',A)", &
                trim(varname), trim(file%name)
            stop
        end if

        do i = 1, snc_inq_var%ndims
            write(err_msg, "('getting length for dimension ',I1,' of ''',A,''' in ',A)") &
                i, trim(varname), trim(file%name)
            call snc_handle_error(nf90_inquire_dimension(file%ncid, dimids(i), &
                len = snc_inq_var%dims(i)), err_msg, src_file, src_line)
        end do

        if (present(units)) call snc_get_att(file, snc_inq_var, "units", units)
    end function snc_inq_var

    ! Define a variable for the NetCDF file with the given name and type; the
    ! dimids are the values returned by snc_def_dim.
    function snc_def_var(file, varname, vartype, dimids, src_file, src_line)
        type(SNCFile), intent(in) :: file
        character(*), intent(in) :: varname
        integer, intent(in) :: vartype
        integer, intent(in), dimension(:) :: dimids
        character(*), intent(in), optional :: src_file
        integer, intent(in), optional :: src_line
        type(SNCVar) :: snc_def_var
        character(700) :: err_msg
        integer :: i, ndims

        write(err_msg, "('defining variable ''',A,''' in ',A)") trim(varname), trim(file%name)
        call snc_handle_error( &
            nf90_def_var(file%ncid, varname, vartype, dimids, snc_def_var%id &
#ifdef HAVE_NETCDF4
              , deflate_level = SNC_DEFAULT_DEFLATE &
#endif
            ), err_msg, src_file, src_line)
        snc_def_var%name = varname
        ndims = size(dimids)
        snc_def_var%ndims = ndims
        do i = 1, ndims
            snc_def_var%dims(i) = snc_get_dim(file, dimids(i), src_file, src_line)
        end do
    end function snc_def_var



    ! READ VAR SECTION ---

% (1..4).each do |n|
%   "ifd".each_char do |t|
    subroutine snc_read<%= n %><%= t %>(file, var, data, timestep, &
        src_file, src_line)
        type(SNCFile), intent(in) :: file
        type(SNCVar), intent(in) :: var
        <%= TYPE[t] %>, pointer :: data(<%= ([':'] * n).join(',') %>)
        integer, intent(in), optional :: timestep
        character(*), intent(in), optional :: src_file
        integer, intent(in), optional :: src_line
        integer, dimension(<%= n + 1 %>) :: start, count
        character(700) :: err_msg

        allocate(data(<%= (1..n).map {|i| "var%dims(#{i})"}.join(', ') %>))
        write(err_msg, "('reading <%= n %>d int variable ''',A,''' in ',A)") &
            trim(var%name), trim(file%name)

        if (present(timestep)) then
            if (var%ndims /= <%= n + 1 %>) stop "expected <%= n + 1 %> dimensional data array to read into"
            start(:<%= n %>) = 1
            start(<%= n + 1 %>) = timestep
            count(:<%= n %>) = var%dims(:<%= n %>)
            count(<%= n + 1 %>) = 1
            call snc_handle_error(nf90_get_var(file%ncid, var%id, data, &
                start, count), err_msg, src_file, src_line)
        else
            call snc_handle_error(nf90_get_var(file%ncid, var%id, data), &
                err_msg, src_file, src_line)
        end if
    end subroutine snc_read<%= n %><%= t %>


%   end

% end

    ! WRITE VAR SECTION ---

% (1..4).each do |n|
%   "ifd".each_char do |t|
    subroutine snc_write<%= n %><%= t %>(file, var, data, timestep, &
        src_file, src_line)
        type(SNCFile), intent(in) :: file
        type(SNCVar), intent(in) :: var
        <%= TYPE[t] %>, intent(in), dimension(<%= ([':'] * n).join(',') %>) :: data
        integer, intent(in), optional :: timestep
        character(*), intent(in), optional :: src_file
        integer, intent(in), optional :: src_line
        integer, dimension(<%= n + 1 %>) :: start, count
        character(700) :: err_msg
        integer :: status

        if (present(timestep)) then
            if (var%ndims /= <%= n + 1 %>) stop "expected <%= n + 1 %> dimensional data array to write from"
            start(:<%= n %>) = 1
            start(<%= n + 1 %>) = timestep
            count(:<%= n %>) = var%dims(:<%= n %>)
            count(<%= n + 1 %>) = 1
            status = nf90_put_var(file%ncid, var%id, data, start, count)
        else
            status = nf90_put_var(file%ncid, var%id, data)
        end if
        write(err_msg, "('writing <%= n %>d int variable ''',A,''' to ',A)") &
            trim(var%name), trim(file%name)
        call snc_handle_error(status, err_msg, src_file, src_line)
    end subroutine snc_write<%= n %><%= t %>


%   end

% end

    ! ATTRIBUTE SECTION ---

    ! Read an attribute from the NetCDF file
% %w(_str i f d).each do |t|
    subroutine snc_get_att<%= t %>(file, var, attname, attvalue, src_file, src_line)
        type(SNCFile), intent(in) :: file
        type(SNCVar), intent(in) :: var
        character(*), intent(in) :: attname
        <%= TYPE[t] %>, intent(out) :: attvalue
        character(*), intent(in), optional :: src_file
        integer, intent(in), optional :: src_line
        character(800) :: err_msg

        write(err_msg, "('getting <%= TYPE[t] %> attribute ''',A,':',A,''' in ',A)") &
            trim(var%name), trim(attname), trim(file%name)
        call snc_handle_error(nf90_get_att(file%ncid, var%id, attname, attvalue), &
            err_msg, src_file, src_line)
    end subroutine snc_get_att<%= t %>


    subroutine snc_get_gatt<%= t %>(file, attname, attvalue, src_file, src_line)
        type(SNCFile), intent(in) :: file
        character(*), intent(in) :: attname
        <%= TYPE[t] %>, intent(out) :: attvalue
        character(*), intent(in), optional :: src_file
        integer, intent(in), optional :: src_line
        type(SNCVar) :: var

        var%id = NF90_GLOBAL
        var%name = "(global)"
        call snc_get_att<%= t %>(file, var, attname, attvalue, src_file, src_line)
    end subroutine snc_get_gatt<%= t %>


% end


    ! Write an attribute to the NetCDF file.
% %w(_str i f d).each do |t|
    subroutine snc_put_att<%= t %>(file, var, attname, attvalue, src_file, src_line)
        type(SNCFile), intent(in) :: file
        type(SNCVar), intent(in) :: var
        character(*), intent(in) :: attname
        <%= TYPE[t] %>, intent(in) :: attvalue
        character(*), intent(in), optional :: src_file
        integer, intent(in), optional :: src_line
        character(700) :: err_msg

        write(err_msg, "('creating <%= TYPE[t] %> attribute ''',A,''' for variable ',A,' in ',A)") &
            trim(attname), trim(var%name), trim(file%name)
        call snc_handle_error(nf90_put_att(file%ncid, var%id, attname, attvalue), &
            err_msg, src_file, src_line)
    end subroutine snc_put_att<%= t %>


    subroutine snc_put_gatt<%= t %>(file, attname, attvalue, src_file, src_line)
        type(SNCFile), intent(in) :: file
        character(*), intent(in) :: attname
        <%= TYPE[t] %>, intent(in) :: attvalue
        character(*), intent(in), optional :: src_file
        integer, intent(in), optional :: src_line
        type(SNCVar) :: var

        var%id = NF90_GLOBAL
        var%name = "(global)"
        call snc_put_att<%= t %>(file, var, attname, attvalue, src_file, src_line)
    end subroutine snc_put_gatt<%= t %>


% end


    ! Finish the NetCDF data definition and prepare for reading. Call when
    ! you are ready to write variables to the file.
    subroutine snc_enddef(file, src_file, src_line)
        type(SNCFile), intent(in) :: file
        character(*), intent(in), optional :: src_file
        integer, intent(in), optional :: src_line
        character(550) :: err_msg

        write(err_msg, "('Ending header definition for ',A)") trim(file%name)
        call snc_handle_error(nf90_enddef(file%ncid), err_msg, src_file, src_line)
    end subroutine snc_enddef

    ! Closes the NetCDF file after you are done reading from or writing to it.
    subroutine snc_close(file, src_file, src_line)
        type(SNCFile), intent(in) :: file
        character(*), intent(in), optional :: src_file
        integer, intent(in), optional :: src_line
        character(520) :: err_msg

        write(err_msg, "('closing ',A)") trim(file%name)
        call snc_handle_error(nf90_close(file%ncid), err_msg, src_file, src_line)
    end subroutine snc_close



    ! Check the return status of a NetCDF function.  If there is an error,
    ! it prints the NetCDF error string, the error message if given, then
    ! stops the program.
    subroutine snc_handle_error(status, message, src_file, src_line)
        integer, intent(in) :: status
        character(*), intent(in), optional :: message
        character(*), intent(in), optional :: src_file
        integer, intent(in), optional :: src_line

        if (status /= NF90_NOERR) then
            if (present(src_file) .and. present(src_line)) then
                write(*, "(A,' line',I5,': ',A)") &
                    src_file, src_line, trim(nf90_strerror(status))
            else
                print *, trim(nf90_strerror(status))
            end if
            if (present(message)) print "('   While: ',A)", trim(message)
            stop
        end if
    end subroutine snc_handle_error

end module SimpleNetCDF
