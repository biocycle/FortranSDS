#!/usr/bin/env ruby

USAGE = "fdoc [-o OUTDIR] FILE.F90..."

class FortranElement
  attr_accessor :file, :line
  attr_accessor :context
  attr_accessor :comment_block
  attr_accessor :name

  def initialize(f, l, ctx, cb, n)
    @file = f
    @line = l
    @context = ctx.last #reverse.find {|c| String !== c}
    @comment_block = cb
    @name = n
  end

  def nodoc?
    @comment_block and @comment_block.any? {|c| c =~ /^!\s*:nodoc:/i }
  end
end

class Mod < FortranElement
end

class Prog < FortranElement
end

class WithMemb < FortranElement
  attr_accessor :members

  def initialize(f, l, ctx, cb, n)
    super(f, l, ctx, cb, n)
    @members = []
  end
end

class Type < WithMemb
end

class Iface < WithMemb
end

class Routine < WithMemb
  attr_accessor :params

  # remove local vars from members list
  def filter_locals!
    # unwrap lines
    lines = []
    i = 0
    while i < @members.length
      if @members[i] =~ /(&\s*)$/
        lines << @members[i][0...-$1.length] + @members[i + 1]
        i += 2
      else
        lines << @members[i]
        i += 1
      end
    end

    # split into type and vars, then keep params or fun names
    decls = []
    lines.each do |line|
      line =~ /(.*)::(.*)/
      type,vars = $1.strip,$2.comment_strip
      vars = vars.split(/\s*,\s*/).each do |var|
        var =~ /(\w[\w\d]*)/
        varname = $1
        if @params.member?(varname) or (Fun === self && varname == @name)
          decls << [type, var]
        end
      end
    end

    @members = decls
  end
end

class Sub < Routine
  def kind
    "subroutine"
  end
end

class Fun < Routine
  def kind
    "function"
  end
end

class String
  # like strip, but also removes fortran comments
  def comment_strip
    s = strip
    if (i = s.index('!'))
      s[0...i]
    else
      s
    end
  end
end


$outdir = 'doc'
$modules = []
$programs = []
$types = []
$consts = []
$interfaces = []
$routines = []


def main
  if ARGV.length < 1
    puts USAGE
    exit -1
  end

  ARGV.each do |infile|
    File.open(infile) {|fin| parse(fin) }
  end

  $modules.delete_if {|r| r.nodoc? }
  $programs.delete_if {|r| r.nodoc? }
  $types.delete_if {|r| r.nodoc? }
  $interfaces.delete_if {|r| r.nodoc? }
  $routines.delete_if {|r| r.nodoc? }
  $routines.each {|r| r.filter_locals! }

  output_markdown
end

def output_markdown
  def header(text, level = 2)
    buf = text + "\n"
    case level
    when 1
      buf << "=" * text.length
    when 2
      buf << "-" * text.length
    else
      raise "Unsupported header level #{level}"
    end
    buf << "\n\n"
  end

  def comment_block(fe)
    if fe.comment_block
      puts parse_comment_block fe.comment_block
      puts "\n\n"
    end
  end

  $modules.each do |mod|
    puts header("Module #{mod.name}", 1)
    puts parse_comment_block mod.comment_block if mod.comment_block
    puts

    $types.each do |type|
      if type.context == mod
        puts header("Type #{type.name}")

        puts "    type #{type.name}"
        type.members.each do |vars|
          puts "        #{vars}"
        end
        puts "    end type\n\n"

        comment_block(type)
      end
    end

    $interfaces.each do |intf|
      if intf.context == mod
        puts header("Interface #{intf.name}")

        puts "    interface #{intf.name}"
        intf.members.each do |funs|
          puts "        #{funs}"
        end
        puts "    end interface\n\n"

        comment_block(intf)
       end
    end

    $routines.each do |rtn|
      if rtn.context == mod
        puts header("#{rtn.kind.capitalize} #{rtn.name}")

        puts "    #{rtn.kind} #{rtn.name}(#{rtn.params.join(', ')})"
        rtn.members.each do |member|
          puts "        #{member.first} :: #{member.last}"
        end
        puts "    end #{rtn.kind}\n\n"

        comment_block(rtn)
      end
    end
  end
end

# extract documentation from a source file
def parse(fin)
  outfile = "#{$outdir}/#{fin.path}.html"

  context = []
  comment_block = nil
  continued = false
  was_var_decl = false
  was_routine = false

  fin.each_line do |line|
    case line
    when /^\s*end\s*(?:(\w+)(?:\s+(\w[\w\d]*))?)?/i
      what,name = $1.downcase,$2
      parse_end(context, line, what, name)
      context.pop
    when /^\s*program\s+(\w[\w\d]*)/i
      context.push Prog.new(fin.path, fin.lineno, context, comment_block, $1)
      $programs << context.last
    when /^\s*module\s+(\w[\w\d]+)(?:\s+(\w[\w\d]*(?:\s*,\s*\w[\w\d]*)*))?/i
      name,procs = $1,$2
      if name =~ /^procedure$/i
        intf = context.last
        unless Iface === intf
          raise "Parse error expected interface procedure list in #{line}"
        end
        intf.members = procs.scan(/\w[\w\d]*/)
      else
        context.push Mod.new(fin.path, fin.lineno, context, comment_block, name)
        $modules << context.last
      end
    when /^\s*interface\s+(\w[\w\d]*)/i
      context.push Iface.new(fin.path, fin.lineno, context, comment_block, $1)
      $interfaces << context.last
    when /^\s*function\s+(\w[\w\d]*)\s*\(([^)&]*)/i
      name,params = $1,$2
      context.push Fun.new(fin.path, fin.lineno, context, comment_block, name)
      $routines << context.last
      context.last.params = params.scan(/\w[\w\d]*/)
      was_routine = true
    when /^\s*subroutine\s+(\w[\w\d]*)\s*\(([^)&]*)/i
      name,params = $1,$2
      context.push Sub.new(fin.path, fin.lineno, context, comment_block, name)
      $routines << context.last
      context.last.params = params.scan(/\w[\w\d]*/)
      was_routine = true
    when /^\s*type\s+(\w[\w\d]*)/i
      context.push Type.new(fin.path, fin.lineno, context, comment_block, $1)
      $types << context.last
    when /^\s*if\s+/i
      context.push 'if'
    when /^\s*do\s+/i
      context.push 'do'
    when /^\s*select\s+/i
      context.push 'select'
    when /^\s*block\s+/i
      context.push 'block'
    when /^\s*where\s+/i
      context.push 'where'
    when /^\s*(?:integer|real|double|complex|character|logical|(?:type\()).*::.+/i
      t = context.last
      if t.respond_to?(:members)
        t.members << line.comment_strip
      end
    when /^\s*(\w[\w\d]*(?:\s*,\s*\w[\w\d]*)*)/i
      if continued
        cl = context.last
        m = line.scan(/\w[\w\d]*/)
        if Iface === cl
          cl.members += m
        elsif Routine === cl
          if was_var_decl
            cl.members << line.comment_strip
          elsif was_routine
            cl.params += m
          end
        end
      end
    end

    if line =~ /^\s*!/
      comment_block ||= []
      comment_block << line.strip + "\n"
    elsif comment_block
      comment_block = nil
    end

    continued = (line =~ /&\s*$/)
    was_var_decl = (line =~ /::/)
    if was_var_decl
      was_routine = false
    end
  end
end

def parse_end(context, line, what, name)
  return unless what # just assume it's cool

  case what
  when 'program'
  when 'module'
  when 'interface'
  when 'function'
  when 'subroutine'
    # XXX check the types on these
  when 'type'
    unless Type === context.last
      raise "Unmatched end at '#{line}'"
    end
    if name and context.last.name != name
      raise "Unmatched end at #{line}"
    end
  when 'if', 'do', 'select', 'block', 'where'
    if what and what != context.last
      raise "Parse Error at #{line}"
    end
  else
    raise "Unrecognized end statement #{line}"
  end
end

def parse_comment_block(comment_block)
  # scan for smallest indentation
  min_indent = find_min_indent(comment_block, /^!(\s*)/) + 1

  # group by param:s and paragraphs
  groups = []
  last_was = nil
  param_indent = nil
  comment_block.each do |line|
    line =~ /^!(\s*)(?:(?:(\w[\w\d]*): (.+))|(.*))?/
    indent,param,defn,text = $1.length,$2,$3,$4
    if param
      param_indent = indent
      groups << [param, defn]
      last_was = :param
    elsif last_was == :param and indent > param_indent # continue param:
      groups.last << line[param_indent..-1]
    elsif text.length > 0
      if last_was == :paragraph
        groups.last << ' ' # space separator between joined lines
      else
        groups << '' # new paragraph
      end
      groups.last << line[min_indent..-1].rstrip
      last_was = :paragraph
    else # end of paragraph
      last_was = nil
    end
  end

  # unindent and join param: lines
  groups = groups.map do |group|
    if String === group
      group
    elsif group.length == 2
      [group[0], group[1].strip]
    else
      param_name = group.shift
      buf = group.shift.strip
      cont_indent = find_min_indent(group, /^(\s+)/)
      last_was_block = nil
      group.each do |l|
        l =~ /^(\s+)/
        indent = $1.length
        if indent > cont_indent # block-indent
          buf << "\n\n" unless last_was_block
          buf << l[cont_indent..-1].rstrip + "\n"
          last_was_block = true
        else
          buf << (last_was_block ? "\n" : ' ')
          buf << l.strip
          last_was_block = nil
        end
      end
      [param_name, buf]
    end
  end

  # mark up the params as definitions
  buf = ''
  seen_param = false
  groups.each do |group|
    if String === group
      buf << "</dl>\n\n" if seen_param
      seen_param = false
      buf << "#{group}\n\n"
    else
      buf << "\n<dl>" unless seen_param
      seen_param = true

      buf << "\n  <dt>#{group.shift}</dt>\n  <dd>"
      buf << group.join("\n") << "</dd>\n"
    end
  end
  buf << "</dl>\n" if seen_param

  buf
end

def find_min_indent(lines, pat)
  min_indent = 1000
  lines.each do |line|
    line =~ pat
    indent = $1.length
    min_indent = indent if indent < min_indent
  end
  min_indent
end

# run script
main
