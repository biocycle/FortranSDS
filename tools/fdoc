#!/usr/bin/env ruby

USAGE = "fdoc [-o OUTDIR] FILE.F90..."

class FortranElement
  attr_accessor :file, :line
  attr_accessor :context
  attr_accessor :comment_block
  attr_accessor :name

  def initialize(f, l, ctx, cb, n)
    @file = f
    @line = l
    @context = ctx.last #reverse.find {|c| String !== c}
    @comment_block = cb
    @name = n
  end

  def nodoc?
    @comment_block =~ /^!\s*:nodoc:/i
  end
end

class Mod < FortranElement
end

class Prog < FortranElement
end

class WithMemb < FortranElement
  attr_accessor :members

  def initialize(f, l, ctx, cb, n)
    super(f, l, ctx, cb, n)
    @members = []
  end
end

class Type < WithMemb
end

class Iface < WithMemb
end

class Routine < WithMemb
  attr_accessor :params
end

class Sub < Routine
  def kind
    "subroutine"
  end
end

class Fun < Routine
  def kind
    "function"
  end
end


$outdir = 'doc'
$modules = []
$programs = []
$types = []
$interfaces = []
$routines = []


def main
  if ARGV.length < 1
    puts USAGE
    exit -1
  end

  ARGV.each do |infile|
    File.open(infile) {|fin| parse(fin) }
  end

  $modules.delete_if {|r| r.nodoc? }
  $programs.delete_if {|r| r.nodoc? }
  $types.delete_if {|r| r.nodoc? }
  $interfaces.delete_if {|r| r.nodoc? }
  $routines.delete_if {|r| r.nodoc? }

  $modules.each do |mod|
    puts mod.comment_block if mod.comment_block
    puts "module #{mod.name}"
  end

  $programs.each do |prog|
    puts prog.comment_block if prog.comment_block
    puts "program #{prog.name}"
  end

  $types.each do |type|
    puts
    puts type.comment_block if type.comment_block
    puts "type #{type.name}"
    type.members.each do |member|
      puts "    #{member}"
    end
    puts "end type #{type.name}"
  end

  $interfaces.each do |intf|
    puts
    puts intf.comment_block if intf.comment_block
    puts "interface #{intf.name}"
    intf.members.each do |member|
      puts "    #{member}"
    end
  end

  $routines.each do |r|
    puts
    puts r.comment_block if r.comment_block
    puts "#{r.kind} #{r.name}(#{r.params.join(', ')})"
    r.members.each do |member|
      puts "    #{member}"
    end
  end
end

class String
  # like strip, but also removes fortran comments
  def comment_strip
    s = strip
    if (i = s.index('!'))
      s[0...i]
    else
      s
    end
  end
end

# extract documentation from a source file
def parse(fin)
  outfile = "#{$outdir}/#{fin.path}.html"

  context = []
  comment_block = ''
  continued = false

  fin.each_line do |line|
#puts "line #{line.inspect}"

    case line
    when /^\s*end\s*(?:(\w+)(?:\s+(\w[\w\d]*))?)?/i
      what,name = $1.downcase,$2
      parse_end(context, line, what, name)
      context.pop
    when /^\s*program\s+(\w[\w\d]+)/i
      context.push Prog.new(fin.path, fin.lineno, context, comment_block, $1)
      $programs << context.last
    when /^\s*module\s+(\w[\w\d]+)(?:\s+(\w[\w\d]*(?:\s*,\s*\w[\w\d]*)*))?/i
      name,procs = $1,$2
      if name =~ /^procedure$/i
        intf = context.last
        unless Iface === intf
          raise "Parse error expected interface procedure list in #{line}"
        end
        intf.members = procs.scan(/\w[\w\d]+/)
      else
        context.push Mod.new(fin.path, fin.lineno, context, comment_block, name)
        $modules << context.last
      end
    when /^\s*interface\s+(\w[\w\d]+)/i
      context.push Iface.new(fin.path, fin.lineno, context, comment_block, $1)
      $interfaces << context.last
    when /^\s*function\s+(\w[\w\d]+)\s*\(([^)&]*)/i
      name,params = $1,$2
      context.push Fun.new(fin.path, fin.lineno, context, comment_block, name)
      $routines << context.last
      context.last.params = params.scan(/\w[\w\d]+/)
    when /^\s*subroutine\s+(\w[\w\d]+)\s*\(([^)&]*)/i
      name,params = $1,$2
      context.push Sub.new(fin.path, fin.lineno, context, comment_block, name)
      $routines << context.last
      context.last.params = params.scan(/\w[\w\d]+/)
    when /^\s*type\s+(\w[\w\d]*)/i
      context.push Type.new(fin.path, fin.lineno, context, comment_block, $1)
      $types << context.last
    when /^\s*if\s+/i
      context.push 'if'
    when /^\s*do\s+/i
      context.push 'do'
    when /^\s*select\s+/i
      context.push 'select'
    when /^\s*block\s+/i
      context.push 'block'
    when /^\s*where\s+/i
      context.push 'where'
    when /^\s*(?:integer|real|double|complex|character|logical|(?:type\()).*::.+/i
      t = context.last
      if t.respond_to?(:members)
        t.members << line.comment_strip
      end
    when /^\s*(\w[\w\d]*(?:\s*,\s*\w[\w\d]*)*)/i
      if continued
        cl = context.last
        m = line.scan(/\w[\w\d]+/)
        if Iface === cl
          cl.members += m
        elsif cl.respond_to?(:params)
          cl.params += m
        end
      end
    end

    if line =~ /^\s*!/
      comment_block ||= ''
      comment_block << line.strip << "\n"
    elsif comment_block
      comment_block = nil
    end

    continued = (line =~ /&\s*$/)
  end
end

def parse_end(context, line, what, name)
  return unless what # just assume it's cool

  case what
  when 'program'
  when 'module'
  when 'interface'
  when 'function'
  when 'subroutine'
    # XXX check the types on these
  when 'type'
    unless Type === context.last
      raise "Unmatched end at '#{line}'"
    end
    if name and context.last.name != name
      raise "Unmatched end at #{line}"
    end
  when 'if', 'do', 'select', 'block', 'where'
    if what and what != context.last
      raise "Parse Error at #{line}"
    end
  else
    raise "Unrecognized end statement #{line}"
  end
end

# run script
main
