#!/usr/bin/env ruby

USAGE = "fdoc [-o OUTDIR] FILE.F90..."

class FortranElement
  attr_accessor :file, :line
  attr_accessor :context
  attr_accessor :comment_block
  attr_accessor :name

  def initialize(f, l, ctx, cb, n)
    @file = f
    @line = l
    @context = ctx.last #reverse.find {|c| String !== c}
    @comment_block = cb
    @name = n
  end

  def nodoc?
    @comment_block and @comment_block.any? {|c| c =~ /^!\s*:nodoc:/i }
  end

  def comment_block_to_html
    return nil unless @comment_block

    # scan for smallest indentation
    min_indent = 1000
    @comment_block.each do |l|
      l =~ /^!(\s*)/
      indent = $1.length
      min_indent = indent if indent < min_indent
    end
    min_indent += 1 # for '!' comment character

    # group by param:s and paragraphs
    groups = []
    last_was = nil
    param_indent = nil
    @comment_block.each do |l|
      case l
      when /^!(\s*)(\w[\w\d]*): /
        # param: section
        param_indent = $1.length
        groups << l[param_indent + 1..-1].split(': ', 2)
        last_was = :param
      when /^!(\s*)$/ # end of paragraph
        last_was = nil
      else
        l =~ /^!(\s*)/
        indent = $1.length
        if last_was == :param and indent > param_indent
          # continue param: section
          groups.last << l[param_indent..-1]
        else
          if last_was == :paragraph
            groups.last << ' ' # space separator between joined lines
          else
            groups << '' # new paragraph
          end
          groups.last << l[min_indent..-1].rstrip
          last_was = :paragraph
        end
      end
    end

    # unindent and join param: lines
    groups = groups.map do |group|
      if String === group
        group
      elsif group.length == 2
        [group[0], group[1].strip]
      else
        param_name = group.shift
        s = group.shift.strip
        cont_indent = 1000
        group.each do |l|
          l =~ /^(\s+)/
          indent = $1.length
          cont_indent = indent if indent < cont_indent
        end
        last_was_block = nil
        group.each do |l|
          l =~ /^(\s+)/
          indent = $1.length
          if indent > cont_indent # block-indent
            s << "\n\n" unless last_was_block
            s << l[cont_indent..-1].rstrip + "\n"
            last_was_block = true
          else
            if last_was_block
              s << "\n"
            else
              s << ' '
            end
            s << l.strip
            last_was_block = nil
          end
        end
        [param_name, s]
      end
    end

    # feed resulting string through markdown -> html

    groups.inspect
  end
end

class Mod < FortranElement
end

class Prog < FortranElement
end

class WithMemb < FortranElement
  attr_accessor :members

  def initialize(f, l, ctx, cb, n)
    super(f, l, ctx, cb, n)
    @members = []
  end
end

class Type < WithMemb
end

class Iface < WithMemb
end

class Routine < WithMemb
  attr_accessor :params

  # remove local vars from members list
  def filter_locals!
    # unwrap lines
    lines = []
    i = 0
    while i < @members.length
      if @members[i] =~ /(&\s*)$/
        lines << @members[i][0...-$1.length] + @members[i + 1]
        i += 2
      else
        lines << @members[i]
        i += 1
      end
    end

    # split into type and vars, then keep params or fun names
    decls = []
    lines.each do |line|
      line =~ /(.*)::(.*)/
      type,vars = $1.strip,$2.comment_strip
      vars = vars.split(/\s*,\s*/).each do |var|
        var =~ /(\w[\w\d]*)/
        varname = $1
        if @params.member?(varname) or (Fun === self && varname == @name)
          decls << [type, var]
        end
      end
    end

    @members = decls
  end
end

class Sub < Routine
  def kind
    "subroutine"
  end
end

class Fun < Routine
  def kind
    "function"
  end
end


$outdir = 'doc'
$modules = []
$programs = []
$types = []
$interfaces = []
$routines = []


def main
  if ARGV.length < 1
    puts USAGE
    exit -1
  end

  ARGV.each do |infile|
    File.open(infile) {|fin| parse(fin) }
  end

  $modules.delete_if {|r| r.nodoc? }
  $programs.delete_if {|r| r.nodoc? }
  $types.delete_if {|r| r.nodoc? }
  $interfaces.delete_if {|r| r.nodoc? }
  $routines.delete_if {|r| r.nodoc? }
  $routines.each {|r| r.filter_locals! }

  $modules.each do |mod|
    puts mod.comment_block_to_html if mod.comment_block
    puts "module #{mod.name}"
  end

  $programs.each do |prog|
    puts prog.comment_block_to_html if prog.comment_block
    puts "program #{prog.name}"
  end

  $types.each do |type|
    puts
    puts type.comment_block_to_html if type.comment_block
    puts "type #{type.name}"
    type.members.each do |member|
      puts "    #{member}"
    end
    puts "end type #{type.name}"
  end

  $interfaces.each do |intf|
    puts
    puts intf.comment_block_to_html if intf.comment_block
    puts "interface #{intf.name}"
    intf.members.each do |member|
      puts "    #{member}"
    end
  end

  $routines.each do |r|
    puts
    puts r.comment_block_to_html if r.comment_block
    puts "#{r.kind} #{r.name}(#{r.params.join(', ')})"
    r.members.each do |member|
      puts "    #{member.first} :: #{member.last}"
    end
  end
end

class String
  # like strip, but also removes fortran comments
  def comment_strip
    s = strip
    if (i = s.index('!'))
      s[0...i]
    else
      s
    end
  end
end

# extract documentation from a source file
def parse(fin)
  outfile = "#{$outdir}/#{fin.path}.html"

  context = []
  comment_block = nil
  continued = false
  was_var_decl = false
  was_routine = false

  fin.each_line do |line|
    case line
    when /^\s*end\s*(?:(\w+)(?:\s+(\w[\w\d]*))?)?/i
      what,name = $1.downcase,$2
      parse_end(context, line, what, name)
      context.pop
    when /^\s*program\s+(\w[\w\d]*)/i
      context.push Prog.new(fin.path, fin.lineno, context, comment_block, $1)
      $programs << context.last
    when /^\s*module\s+(\w[\w\d]+)(?:\s+(\w[\w\d]*(?:\s*,\s*\w[\w\d]*)*))?/i
      name,procs = $1,$2
      if name =~ /^procedure$/i
        intf = context.last
        unless Iface === intf
          raise "Parse error expected interface procedure list in #{line}"
        end
        intf.members = procs.scan(/\w[\w\d]*/)
      else
        context.push Mod.new(fin.path, fin.lineno, context, comment_block, name)
        $modules << context.last
      end
    when /^\s*interface\s+(\w[\w\d]*)/i
      context.push Iface.new(fin.path, fin.lineno, context, comment_block, $1)
      $interfaces << context.last
    when /^\s*function\s+(\w[\w\d]*)\s*\(([^)&]*)/i
      name,params = $1,$2
      context.push Fun.new(fin.path, fin.lineno, context, comment_block, name)
      $routines << context.last
      context.last.params = params.scan(/\w[\w\d]*/)
      was_routine = true
    when /^\s*subroutine\s+(\w[\w\d]*)\s*\(([^)&]*)/i
      name,params = $1,$2
      context.push Sub.new(fin.path, fin.lineno, context, comment_block, name)
      $routines << context.last
      context.last.params = params.scan(/\w[\w\d]*/)
      was_routine = true
    when /^\s*type\s+(\w[\w\d]*)/i
      context.push Type.new(fin.path, fin.lineno, context, comment_block, $1)
      $types << context.last
    when /^\s*if\s+/i
      context.push 'if'
    when /^\s*do\s+/i
      context.push 'do'
    when /^\s*select\s+/i
      context.push 'select'
    when /^\s*block\s+/i
      context.push 'block'
    when /^\s*where\s+/i
      context.push 'where'
    when /^\s*(?:integer|real|double|complex|character|logical|(?:type\()).*::.+/i
      t = context.last
      if t.respond_to?(:members)
        t.members << line.comment_strip
      end
    when /^\s*(\w[\w\d]*(?:\s*,\s*\w[\w\d]*)*)/i
      if continued
        cl = context.last
        m = line.scan(/\w[\w\d]*/)
        if Iface === cl
          cl.members += m
        elsif Routine === cl
          if was_var_decl
            cl.members << line.comment_strip
          elsif was_routine
            cl.params += m
          end
        end
      end
    end

    if line =~ /^\s*!/
      comment_block ||= []
      comment_block << line.strip + "\n"
    elsif comment_block
      comment_block = nil
    end

    continued = (line =~ /&\s*$/)
    was_var_decl = (line =~ /::/)
    if was_var_decl
      was_routine = false
    end
  end
end

def parse_end(context, line, what, name)
  return unless what # just assume it's cool

  case what
  when 'program'
  when 'module'
  when 'interface'
  when 'function'
  when 'subroutine'
    # XXX check the types on these
  when 'type'
    unless Type === context.last
      raise "Unmatched end at '#{line}'"
    end
    if name and context.last.name != name
      raise "Unmatched end at #{line}"
    end
  when 'if', 'do', 'select', 'block', 'where'
    if what and what != context.last
      raise "Parse Error at #{line}"
    end
  else
    raise "Unrecognized end statement #{line}"
  end
end

# run script
main
